input {
  beats {
    port => "5000"
  }
}

# The filter part of this file is commented out to indicate that it is
# optional.
# filter {
# }

filter {


  # grok  {
  #   match => {
  #     "message" => [
  #       "%{TIMESTAMP_ISO8601:timestamp};%{WORD:process_id};%{NUMBER:pid};%{WORD:status_code};%{NUMBER:status_num}",
  #       "%{TIMESTAMP_ISO8601:timestamp};%{WORD:process_id};%{NUMBER:pid};%{WORD:status_code}*"
  #     ]
  #   }
  # }
  

  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp};%{WORD:thread};%{WORD:action} %{WORD:job_type} Job Wfd ID:%{NUMBER:wfd_id} JobId:%{NUMBER:job_id} JobType:%{WORD:job_type} Runtime:%{NUMBER:runtime} Queued:%{NUMBER:queued} Total:%{NUMBER:total}" }
  }
  
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp};%{WORD:thread};%{WORD:action} %{WORD:job_type} Job Wfd ID:%{NUMBER:wfd_id} JobId:%{NUMBER:job_id} JobType:%{WORD:job_type} Queued:%{NUMBER:queued}" }
  }

  #3. grok match for connections
  #1. closing connection matching
  #2. opening connection matching

  # grok {
  #   match => {
  #     "message" => [
  #       "%{TIMESTAMP_ISO8601:timestamp};%{WORD:action};%{NUMBER:number};%{GREEDYDATA:connection_type} to %{IP:target_ip}:%{NUMBER:target_port}",
  #       "%{TIMESTAMP_ISO8601:timestamp};%{GREEDYDATA:connection_type} to %{IP:target_ip}:%{NUMBER:target_port}"
  #     ]
  #   }
  # }

  # if "target_port" in [target_port] {
  #   mutate {
  #     add_field => { "process_id" => "P%{target_port}" }
  #   }
  # }


  date {
    match => ["timestamp", "yyyy-MM-dd HH:mm:ss.SSS"]
    timezone => "Europe/Berlin"
    target => "@timestamp"
    remove_field => ["timestamp"]
    
  }
}

output {
  stdout { codec => rubydebug }
  opensearch {
    hosts => ["http://opensearch:9200"]
    index => "ilgmc-test"
    user => "admin"
    password => "admin"
    ssl => false
    ssl_certificate_verification => false
  }

}
